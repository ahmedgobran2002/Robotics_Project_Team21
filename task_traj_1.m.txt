function Task_Space_1 = task_traj(X0, Xf, Tf, Ts)
    %{
    q0 = deg2rad([0;30;60;45]);
    q = inverse_kinematics(q0,Xf);
    %}

    %{
    % Define inputs
    X0 = input('Enter initial position [x0, y0, z0]: '); % Initial position
    Xf = input('Enter final position [xf, yf, zf]: ');  % Final position
    Tf = input('Enter total time for the trajectory (max 10 sec): '); % Total time
    %}

    X0 = [180, 0, 45];
    Xf = [0, 25, 2];
    Tf = 10;
    Ts = 0.1;
 
    %{
    % Check for valid time input
    if Tf > 10
        error('Time Tf must not exceed 10 seconds.');
    end
    %}

    % Time vector
    timeSteps = 0:Ts:Tf;

    % Number of steps
    nSteps = length(timeSteps);

    % Initialize trajectory data
    trajectory = zeros(nSteps, 3);
    joint_angles = zeros(nSteps, 4);

    for i = 1:nSteps
        t = timeSteps(i) / Tf; 
        trajectory(i, :) = (1 - t) * X0 + t * Xf; 
    end

    
    disp('Trajectory Points (Xf for each time step):');
    disp(trajectory);

    
    %q0 = [1.6; 0.8; 1.1; 1.6]; 
    q0 = deg2rad([0;30;60;45]);
    %joint angles using inverse kinematics
    for i = 1:nSteps
        current_Xf = trajectory(i, :)'; 
        joint_angles(i, :) = inverse_kinematics_func(q0, current_Xf); 
    end

    
    disp('Joint Angles (q) for each time step:');
    disp(joint_angles);

    % Plot results
    figure;

    % Plot trajectory
    subplot(2, 1, 1);
    plot(timeSteps, trajectory(:, 1), 'r', ...
         timeSteps, trajectory(:, 2), 'g', ...
         timeSteps, trajectory(:, 3), 'b');
    xlabel('Time (s)');
    ylabel('Position');
    title('End-Effector Trajectory');
    legend('X', 'Y', 'Z');
    
    % Plot joint angles
    subplot(2, 1, 2);
    plot(timeSteps, joint_angles);
    xlabel('Time (s)');
    ylabel('Joint Angles (rad)');
    title('Joint Angles Trajectory');
    legend('q1', 'q2', 'q3', 'q4');
    
end

function q = inverse_kinematics_func(q0, X)
   
    J_pseudo_inv = J_inv();
    T = forward_kinematics();
    J_Matrix = Differentiation();
    end_effector_position = T(1:3, 4);
    f1 = T(1, 4); %X.E.E
    f2 = T(2, 4); %Y.E.E
    f3 = T(3, 4); %Z.E.E

    % Define symbolic variables
    syms L1 L2 L3 L4 q1 q2 q3 q4

    % Define constants for joints angles
    %q1_num = deg2rad(90);  % Joint 1 angle (degrees to radians)
    %q2_num = deg2rad(45);  % Joint 2 angle (degrees to radians)
    %q3_num = deg2rad(60);  % Joint 3 angle (degrees to radians)
    %q4_num = deg2rad(90);  % Joint 4 angle (degrees to radians)

    % End-effector position matrix in matrix form
    %x_desired = [178.6628; 0; 49.051];
    x_desired = [0; 25; 2];
    %disp(x_desired);
    
    %q0 = deg2rad([0;30;60;45]);
    
    % Define F(Qn) 
    W = [f1; f2; f3];
    %disp(W);
    F_Qn = W - x_desired;

    % Define the joint variables as a vector
    % q_new = [q1; q2; q3; q4];
    
    %random_matrix1 = pi *rand(4, 1);
    %q_old = random_matrix1;
    q_old = [0; 0.5; 1; 0.8]; 

    % Define parameters:
    i = 0;
    error = 10;
    err_toler = 1e-8;   % Convergence tolerance
    max_iters = 100;    % Maximum number of iteration
   
    while(error > err_toler)
        q1_num = q_old(1,1);
        q2_num = q_old(2,1);
        q3_num = q_old(3,1);
        q4_num = q_old(4,1); 
        
        W_sub = subs(W,[q1,q2,q3,q4],[q1_num,q2_num,q3_num,q4_num]); 
        F_Qn = W_sub - x_desired;
        
        p_inv_sub = vpa(subs(pinv(J_Matrix),[q1,q2,q3,q4],[q1_num,q2_num,q3_num,q4_num]));
        
        q_new = vpa(q_old - (p_inv_sub * F_Qn));
        disp('Qnew =');
        disp (q_new);

        error = abs(q_new - q0);
        q_old = q_new;
        i=i+1;
        q = q_new;
        
            if i>max_iters
                disp('Warning: Maximum iterations reached without convergence.');
                random_matrix = pi *rand(4, 1);
                q_old = random_matrix;
            %break;
        end
    end
end 