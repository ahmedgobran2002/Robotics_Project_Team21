function q = inverse_kinematics_func(q0, X)

    J_pseudo_inv = J_inv();
    T = forward_kinematics();
    end_effector_position = T(1:3, 4);
    f1 = T(1, 4); %X.E.E
    f2 = T(2, 4); %Y.E.E
    f3 = T(3, 4); %Z.E.E

    % Define symbolic variables
    syms L1 L2 L3 L4 q1 q2 q3 q4

    % Define constants for joints angles
    %q1_num = deg2rad(90);  % Joint 1 angle (degrees to radians)
    %q2_num = deg2rad(45);  % Joint 2 angle (degrees to radians)
    %q3_num = deg2rad(60);  % Joint 3 angle (degrees to radians)
    %q4_num = deg2rad(90);  % Joint 4 angle (degrees to radians)

    % End-effector position matrix in matrix form
    x_desired = [178.6628; 0; 49.051];
    %disp(x_desired);

    % Define F(Qn) 
    W = [f1; f2; f3];
     %disp(W);
    F_Qn = W - x_desired;

    % Define the joint variables as a vector
  %  q_new = [q1; q2; q3; q4];
    q_old = [1.6; 0.8; 1.1; 1.6]; 

    % Define parameters:
    i = 0;
    error = 11;
    err_toler = 1e-4;   % Convergence tolerance
    max_iters = 100;    % Maximum number of iteration
   
    while(error > err_toler)
        q1_num = q_old(1,1);
        q2_num = q_old(2,1);
        q3_num = q_old(3,1);
        q4_num = q_old(4,1); 
        
        W_sub = subs(W,[q1,q2,q3,q4],[q1_num,q2_num,q3_num,q4_num]); 
        F_Qn = W_sub - x_desired;
        
        p_inv_sub = vpa(subs(J_pseudo_inv,[q1,q2,q3,q4],[q1_num,q2_num,q3_num,q4_num]))
        
        q_new = vpa(q_old - (p_inv_sub * F_Qn));
        disp('Qnew =');
        disp (q_new);

        q_old = q_new;
        
        i=i+1;

        if (i>100)
            disp('Warning: Maximum iterations reached without convergence.');
            random_matrix = pi *rand(4, 1);
            q_old = random_matrix;
            break;
        end
    end
end 